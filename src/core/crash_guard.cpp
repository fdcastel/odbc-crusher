#include "crash_guard.hpp"

#ifdef _WIN32
#include <windows.h>
#else
#include <csignal>
#include <csetjmp>
#include <cstdio>
#endif

#include <sstream>
#include <iostream>

namespace odbc_crusher::core {

#ifdef _WIN32

// SEH exception filter: only catch real crashes, let C++ exceptions propagate
static int crash_filter(unsigned int code) {
    // 0xE06D7363 is the MSVC C++ exception code ('msc' | 0xE0000000)
    // Let these propagate so normal try/catch blocks can handle them.
    if (code == 0xE06D7363) {
        return EXCEPTION_CONTINUE_SEARCH;
    }
    return EXCEPTION_EXECUTE_HANDLER;
}

// SEH wrapper in a plain-C-style function (no C++ objects with destructors)
// The function pointer is passed as a raw pointer to avoid C++ unwind issues.
static int seh_call(void (*raw_func)(void*), void* ctx, unsigned int* out_code) {
    __try {
        raw_func(ctx);
        return 0;  // success
    }
    __except (crash_filter(GetExceptionCode())) {
        *out_code = GetExceptionCode();
        return 1;  // crashed
    }
}

// Trampoline that calls std::function via a raw context pointer
static void trampoline(void* ctx) {
    auto* func = static_cast<const std::function<void()>*>(ctx);
    (*func)();
}

CrashGuardResult execute_with_crash_guard(const std::function<void()>& func) {
    CrashGuardResult result;
    unsigned int code = 0;
    
    // Pass the std::function by pointer through a C-style trampoline
    auto* func_ptr = &func;
    if (seh_call(trampoline, const_cast<void*>(static_cast<const void*>(func_ptr)), &code)) {
        result.crashed = true;
        result.crash_code = code;
        
        std::ostringstream oss;
        switch (code) {
            case EXCEPTION_ACCESS_VIOLATION:
                oss << "Access violation (0xC0000005)";
                break;
            case EXCEPTION_STACK_OVERFLOW:
                oss << "Stack overflow (0xC00000FD)";
                break;
            case EXCEPTION_INT_DIVIDE_BY_ZERO:
                oss << "Division by zero (0xC0000094)";
                break;
            default:
                oss << "Structured exception (0x" << std::hex << code << ")";
                break;
        }
        oss << " - likely a bug in the ODBC driver";
        result.description = oss.str();
    }
    
    return result;
}

#else

// On non-Windows platforms, use signal handlers for SIGSEGV/SIGBUS/SIGABRT.
//
// IMPORTANT: siglongjmp from a hardware-fault signal handler (SIGSEGV, SIGBUS)
// is technically undefined behavior per POSIX when the signal was generated by
// an actual memory access violation (as opposed to raise()/kill()).  In practice,
// it works on x86-64 Linux with glibc for simple null-pointer dereferences, but
// it can leave the process in an unstable state if the faulting code held locks
// or was mid-way through a complex operation.
//
// We mitigate this by:
//   1. Using SA_NODEFER so the signal is NOT blocked after the handler runs.
//      Without this, a second SIGSEGV in a later crash guard would be blocked
//      and the default action (process termination) would take effect instead.
//   2. Flushing stdout/stderr in the crash path so partial output is preserved
//      even if the process becomes unstable and terminates later.
//   3. Re-installing the signal handler before each sigsetjmp, so every
//      execute_with_crash_guard call has a fresh handler.
#include <setjmp.h>

static thread_local sigjmp_buf s_jmp_env;
static thread_local volatile sig_atomic_t s_in_guard = 0;

static void crash_signal_handler(int sig) {
    if (s_in_guard) {
        siglongjmp(s_jmp_env, sig);
    }
    // If not in guard, re-raise with default handler to get a proper core dump
    signal(sig, SIG_DFL);
    raise(sig);
}

CrashGuardResult execute_with_crash_guard(const std::function<void()>& func) {
    CrashGuardResult result;
    
    // Flush all output before entering the guard, so if the process dies
    // during the guarded section, all prior output is preserved.
    std::cout << std::flush;
    std::cerr << std::flush;
    fflush(stdout);
    fflush(stderr);
    
    struct sigaction sa = {};
    struct sigaction old_segv = {}, old_bus = {}, old_fpe = {}, old_abrt = {};
    sa.sa_handler = crash_signal_handler;
    sigemptyset(&sa.sa_mask);
    // SA_NODEFER: don't block the signal while the handler runs.
    // This is critical: after siglongjmp, the signal would remain blocked
    // without this flag.  A subsequent SIGSEGV in a later crash guard call
    // would then be delivered with the default action (process termination)
    // instead of being caught by our handler.
    sa.sa_flags = SA_NODEFER;
    
    sigaction(SIGSEGV, &sa, &old_segv);
    sigaction(SIGBUS, &sa, &old_bus);
    sigaction(SIGFPE, &sa, &old_fpe);
    sigaction(SIGABRT, &sa, &old_abrt);
    
    s_in_guard = 1;
    int sig = sigsetjmp(s_jmp_env, 1);
    
    if (sig == 0) {
        func();
    } else {
        // Crash caught â€” build description using only async-signal-safe-ish ops.
        // We're past the siglongjmp now, so we can use C++ again (carefully).
        result.crashed = true;
        result.crash_code = static_cast<unsigned int>(sig);
        
        std::ostringstream oss;
        switch (sig) {
            case SIGSEGV:
                oss << "Segmentation fault (SIGSEGV)";
                break;
            case SIGBUS:
                oss << "Bus error (SIGBUS)";
                break;
            case SIGFPE:
                oss << "Floating-point exception (SIGFPE)";
                break;
            case SIGABRT:
                oss << "Aborted (SIGABRT)";
                break;
            default:
                oss << "Signal " << sig;
                break;
        }
        oss << " - likely a bug in the ODBC driver";
        result.description = oss.str();
        
        // Flush output immediately so crash report survives even if the
        // process becomes unstable after this point.
        std::cout << std::flush;
        std::cerr << std::flush;
        fflush(stdout);
        fflush(stderr);
    }
    
    s_in_guard = 0;
    sigaction(SIGSEGV, &old_segv, nullptr);
    sigaction(SIGBUS, &old_bus, nullptr);
    sigaction(SIGFPE, &old_fpe, nullptr);
    sigaction(SIGABRT, &old_abrt, nullptr);
    
    return result;
}

#endif

} // namespace odbc_crusher::core

